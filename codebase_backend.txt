Codebase Structure Overview:

└── app
    ├── config.py
    ├── database.py
    ├── main.py
    ├── models.py
    ├── routers
    │   ├── admin.py
    │   ├── ai.py
    │   ├── auth.py
    │   ├── journals.py
    │   └── progress.py
    ├── schemas.py
    ├── security.py
    ├── services
    │   ├── ai_service.py
    │   └── context_agent.py
    └── static
        └── images
            └── icon


==================================================

Compiled Code Contents:


### File: app/schemas.py

```
from pydantic import BaseModel, EmailStr, Field
from datetime import datetime, date
from typing import Optional, List
import enum

# --- Import the new Enums from models ---
from .models import MessageSender, MessageType

# --- User Schemas ---

class UserBase(BaseModel):
    """Base schema for user data, containing common fields."""
    email: EmailStr
    username: str
    realname: Optional[str] = None
    student_id: Optional[str] = None
    group: Optional[str] = None

class UserCreate(UserBase):
    """Schema for creating a new user. Includes the password."""
    password: str = Field(..., max_length=72)
    realname: str
    student_id: str
    group: str

class UserOut(UserBase):
    """Schema for returning user data to the client. Excludes the password."""
    id: int
    created_at: datetime
    is_admin: bool # This field ensures the admin status is sent to the frontend

    class Config:
        from_attributes = True

# --- Token Schemas for Login ---

class Token(BaseModel):
    """Schema for the response when a user logs in successfully."""
    access_token: str
    token_type: str

class TokenData(BaseModel):
    """Schema representing the data embedded within a JWT."""
    id: Optional[str] = None

# --- NEW ChatMessage Schemas ---
class ChatMessageBase(BaseModel):
    sender: MessageSender
    message_text: str
    message_type: MessageType

class ChatMessageOut(ChatMessageBase):
    id: int
    timestamp: datetime

    class Config:
        from_attributes = True

# --- Journal Schemas ---

class JournalBase(BaseModel):
    """Base schema for journal data."""
    title: Optional[str] = None
    outline_content: Optional[str] = None
    content: Optional[str] = None

class JournalCreate(BaseModel):
    """Schema for creating a new journal entry."""
    content: str

class JournalUpdate(BaseModel):
    content: str
    outline_content: Optional[str] = None

class JournalPhase(str, enum.Enum):
    scaffolding = "scaffolding"
    writing = "writing"
    evaluation = "evaluation" # Changed from finishing
    completed = "completed"

class JournalPhaseUpdate(BaseModel):
    phase: JournalPhase


class JournalOut(JournalBase):
    """Schema for returning journal data to the client."""
    id: int
    user_id: int
    journal_date: date
    outline_content: Optional[str] = None
    writing_phase: JournalPhase
    created_at: datetime
    updated_at: datetime
    chat_messages: List[ChatMessageOut] = []
    
    class Config:
        from_attributes = True
        
# --- AI Schemas ---

class AIFeedbackRequest(BaseModel):
    """Schema for the request body when asking for AI feedback."""
    text: str = Field(..., min_length=10, description="The journal text to be analyzed.")

class AIFeedbackItem(BaseModel):
    """Schema for a single piece of feedback from the AI."""
    category: str = Field(..., description="e.g., 'Grammar: Tense', 'Vocabulary: Phrasing'")
    incorrect_phrase: str
    suggestion: str
    explanation: str

class AIFeedbackResponse(BaseModel):
    """The overall response schema for the AI feedback endpoint."""
    high_level_summary: str
    feedback_items: List[AIFeedbackItem]

class AIConceptualFeedbackResponse(BaseModel):
    """Schema for high-level conceptual feedback."""
    feedback_text: str

# --- AI Chat Schemas (New) ---

class AIChatRequest(BaseModel):
    """Schema for the request body when sending a chat message."""
    message: str = Field(..., min_length=1)
    enable_correction: bool = False

class AIChatResponse(BaseModel):
    """Schema for the response from the AI chat endpoint."""
    ai_message: ChatMessageOut

# --- Progress Tracking Schemas ---
class TopTopic(BaseModel):
    """Schema for representing a user's most frequent learning topics."""
    topic_name: str
    error_count: int

    class Config:
        from_attributes = True

class ProgressSummary(BaseModel):
    """Schema for the response of the progress summary endpoint."""
    total_errors: int
    topics_encountered: int
    top_topics: List[TopTopic]

class StreakOut(BaseModel):
    """Schema for returning the user's current streak."""
    streak_count: int

# --- NEW Admin Schemas ---

class AdminErrorDistributionItem(BaseModel):
    """Schema for a single data point in the error distribution chart."""
    topic_name: str
    error_count: int

class AdminErrorTrendPoint(BaseModel):
    """Schema for a single data point in the error trend chart."""
    date: date
    error_count: int

class AdminStudentSummary(UserOut):
    """Schema for listing all students in the admin dashboard."""
    journal_count: int
    total_errors: int
    last_active: Optional[datetime]
    is_admin: bool = False # Override to provide a default, fixing the error.

class AdminStudentDetail(AdminStudentSummary):
    """Schema for the detailed view of a single student."""
    error_distribution: List[AdminErrorDistributionItem]
    error_trend: List[AdminErrorTrendPoint]

# --- NEW Admin Schemas for Whitelist ---
class StudentWhitelistBase(BaseModel):
    student_id: str
    email: EmailStr

class StudentWhitelistCreate(StudentWhitelistBase):
    pass

class StudentWhitelistOut(StudentWhitelistBase):
    id: int
    created_at: datetime

    class Config:
        from_attributes = True

# --- New Schemas for Learning Hub ---

class TopicDetail(BaseModel):
    """Schema for a single error instance within a topic."""
    incorrect_phrase: str
    suggestion_text: str
    explanation_text: str
    repetition_count: int
    last_occurred_at: datetime

    class Config:
        from_attributes = True

class UserTopic(BaseModel):
    """Schema for a topic the user has encountered."""
    topic_id: int
    topic_name: str
    error_count: int

    class Config:
        from_attributes = True

class UserTopicDetails(UserTopic):
    """Extends UserTopic to include the full list of errors."""
    errors: List[TopicDetail]

```


### File: app/security.py

```
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.orm import Session
from passlib.context import CryptContext
from datetime import datetime, timedelta
from jose import JWTError, jwt

from . import database, models, schemas
from .config import settings

# This tells FastAPI where the client should go to get the token.
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/auth/token")

# --- Password Hashing ---
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verifies a plain password against a hashed one."""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Hashes a plain password."""
    return pwd_context.hash(password)


# --- JWT Token Handling ---
def create_access_token(data: dict):
    """
    Creates a JWT access token.
    """
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=settings.access_token_expire_minutes)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.secret_key, algorithm=settings.algorithm)
    return encoded_jwt

def verify_access_token(token: str, credentials_exception):
    """
    Verifies a JWT. Decodes it and validates the user ID.
    """
    try:
        payload = jwt.decode(token, settings.secret_key, algorithms=[settings.algorithm])
        user_id: str = payload.get("user_id")
        if user_id is None:
            raise credentials_exception
        token_data = schemas.TokenData(id=str(user_id))
    except JWTError:
        raise credentials_exception
    return token_data

def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(database.get_db)):
    """
    Dependency to get the current user from a token.
    This will be used to protect endpoints.
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    token_data = verify_access_token(token, credentials_exception)
    user = db.query(models.User).filter(models.User.id == token_data.id).first()
    
    if user is None:
        raise credentials_exception
        
    return user

def get_current_admin_user(current_user: models.User = Depends(get_current_user)):
    """
    Dependency to ensure the current user is an admin.
    Raises an HTTPException if the user is not an admin.
    """
    if not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You do not have permission to access this resource."
        )
    
    return current_user
```


### File: app/models.py

```
from sqlalchemy import Column, Integer, String, Text, Date, ForeignKey, TIMESTAMP, Enum, Boolean
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.orm import relationship
from sqlalchemy.sql.expression import text
from .database import Base
from datetime import datetime

import enum

# Define an Enum for the sender type
class MessageSender(enum.Enum):
    user = "user"
    ai = "ai"

class MessageType(enum.Enum):
    conversation = "conversation"
    feedback = "feedback"
    
# Define an Enum for the journal writing phase
class JournalPhase(enum.Enum):
    scaffolding = "scaffolding"
    writing = "writing"
    evaluation = "evaluation" # Changed from finishing
    completed = "completed"

# --- Authentication and Journaling Models ---

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String(50), unique=True, nullable=False, index=True)
    email = Column(String(255), unique=True, nullable=False, index=True)
    realname = Column(String(100), nullable=True)
    student_id = Column(String(50), unique=True, nullable=True, index=True)
    group = Column(String(50), nullable=True)
    hashed_password = Column(String(255), nullable=False)
    is_admin = Column(Boolean, server_default='f', nullable=False)
    created_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=text("timezone('utc', now())"))
    
    journals = relationship("Journal", back_populates="owner")
    errors = relationship("UserError", back_populates="user")
    context_profile = relationship("UserContextProfile", back_populates="owner", uselist=False, cascade="all, delete-orphan")

# --- NEW Model for Student Whitelist ---
class StudentWhitelist(Base):
    __tablename__ = "student_whitelist"
    id = Column(Integer, primary_key=True, index=True)
    student_id = Column(String(50), unique=True, nullable=False, index=True)
    email = Column(String(255), nullable=False)
    created_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=text("timezone('utc', now())"))


class Journal(Base):
    __tablename__ = "journals"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    journal_date = Column(Date, nullable=False)
    title = Column(String(255), nullable=True)
    content = Column(Text, nullable=True, default='')
    outline_content = Column(Text, nullable=True, default='')
    writing_phase = Column(Enum(JournalPhase), default=JournalPhase.scaffolding, nullable=False)
    session_state = Column(JSONB, nullable=True) # New field for conversation state
    created_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=text("timezone('utc', now())"))
    updated_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=text("timezone('utc', now())"), onupdate=datetime.utcnow)
    
    # Corrected relationships
    owner = relationship("User", back_populates="journals")
    chat_messages = relationship("ChatMessage", back_populates="journal", cascade="all, delete-orphan")

class ChatMessage(Base):
    __tablename__ = "chat_messages"
    id = Column(Integer, primary_key=True, index=True)
    journal_id = Column(Integer, ForeignKey("journals.id", ondelete="CASCADE"), nullable=False)
    sender = Column(Enum(MessageSender), nullable=False)
    message_text = Column(Text, nullable=False)
    message_type = Column(Enum(MessageType), default=MessageType.conversation, nullable=False)
    timestamp = Column(TIMESTAMP(timezone=True), nullable=False, server_default=text("timezone('utc', now())"))

    journal = relationship("Journal", back_populates="chat_messages")

# --- New User Context Profile Model ---
class UserContextProfile(Base):
    __tablename__ = "user_context_profiles"
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), primary_key=True)
    profile_data = Column(JSONB, nullable=False, server_default=text("'{}'::jsonb"))
    last_updated = Column(TIMESTAMP(timezone=True), nullable=False, server_default=text("timezone('utc', now())"), onupdate=datetime.utcnow)

    owner = relationship("User", back_populates="context_profile")


# --- Learning and Progress Tracking Models ---

class LearningTopic(Base):
    __tablename__ = "learning_topics"
    id = Column(Integer, primary_key=True, index=True)
    topic_name = Column(String(100), unique=True, nullable=False)
    description = Column(Text, nullable=True)

class UserError(Base):
    __tablename__ = "user_errors"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    topic_id = Column(Integer, ForeignKey("learning_topics.id"), nullable=False)
    incorrect_phrase = Column(Text, nullable=False)
    repetition_count = Column(Integer, default=1, nullable=False)
    status = Column(String(50), default='active', nullable=False)
    first_occurred_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=text("timezone('utc', now())"))
    last_occurred_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=text("timezone('utc', now())"))
    
    user = relationship("User", back_populates="errors")
    topic = relationship("LearningTopic")
    history = relationship("UserLearningHistory", back_populates="error_instance")

class LearningPoint(Base):
    __tablename__ = "learning_points"
    id = Column(Integer, primary_key=True, index=True)
    topic_id = Column(Integer, ForeignKey("learning_topics.id"), nullable=False)
    explanation_text = Column(Text, nullable=False)
    suggestion_text = Column(Text, nullable=False)

class UserLearningHistory(Base):
    __tablename__ = "user_learning_history"
    id = Column(Integer, primary_key=True, index=True)
    error_id = Column(Integer, ForeignKey("user_errors.id", ondelete="CASCADE"), nullable=False)
    learning_point_id = Column(Integer, ForeignKey("learning_points.id"), nullable=False)
    timestamp = Column(TIMESTAMP(timezone=True), nullable=False, server_default=text("timezone('utc', now())"))
    error_instance = relationship("UserError", back_populates="history")

```


### File: app/database.py

```
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from .config import settings

# The database URL is read from our settings instance
SQLALCHEMY_DATABASE_URL = settings.database_url

# The engine is the entry point to the database.
engine = create_engine(SQLALCHEMY_DATABASE_URL)

# Each instance of SessionLocal will be a database session.
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Base class that our ORM models will inherit from.
Base = declarative_base()

# Dependency for API endpoints to get a DB session
def get_db():
    """
    A dependency that provides a database session for each request,
    ensuring the session is always closed after the request is finished.
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


```


### File: app/main.py

```
from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware
from . import models
from .database import engine
from .routers import auth, journals, ai, progress, admin
import os

# This line creates the database tables.
models.Base.metadata.create_all(bind=engine)

app = FastAPI()

# --- CORS Middleware Configuration ---
# This is the crucial part to fix the frontend connection errors.
# It tells the browser that it's safe for your frontend to make requests to this backend.

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://it.parasyst.com", "https://ti.parasyst.com", "https://ipa.parasyst.com", "http://localhost:3000", "http://ai-ndhu-lab:3000"],  # For development, ["*"] allows all origins. For production, you should restrict this to your frontend's domain, e.g., ["https://www.lingojourn.com"].
    allow_credentials=True,
    allow_methods=["*"],  # Allows all HTTP methods (GET, POST, PUT, etc.).
    allow_headers=["*"],  # Allows all headers (including Authorization).
)
# --- End of CORS Configuration ---

# --- Static Files Configuration ---
# This section sets up a directory to serve static files like images.

# Create a path to the 'static' directory.
# os.path.dirname(__file__) gets the directory of the current file (main.py).
# We then join it with 'static' to create a full path.
static_files_dir = os.path.join(os.path.dirname(__file__), "static")

# Create the directory if it doesn't exist to prevent errors on first run.
os.makedirs(static_files_dir, exist_ok=True)

# Mount the 'static' directory to the '/static' URL path.
# Any file inside 'app/static/' will be accessible from '/static/'.
# For example, a file at 'app/static/images/logo.png' will be available at
# 'http://your-api-url/static/images/logo.png'
app.mount("/static", StaticFiles(directory=static_files_dir), name="static")
# --- End of Static Files Configuration ---

@app.get("/")
def read_root():
    return {"message": "Welcome to the LingoJourn API!"}


# Include the routers from other files
app.include_router(auth.router)
app.include_router(journals.router)
app.include_router(ai.router)
app.include_router(progress.router)
app.include_router(admin.router)

```


### File: app/config.py

```
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    """
    Manages application settings loaded from environment variables.
    """
    database_url: str
    secret_key: str
    algorithm: str
    access_token_expire_minutes: int
    gemini_api_key: str # Added for the Gemini API

    class Config:
        env_file = ".env"

# Create a single instance of the settings to be used throughout the app
settings = Settings()


```


### File: app/services/context_agent.py

```
import google.generativeai as genai
from sqlalchemy.orm import Session, joinedload
import json
from datetime import datetime

from .. import models, database
from ..config import settings

# Configure the Gemini API client
try:
    genai.configure(api_key=settings.gemini_api_key)
    model = genai.GenerativeModel('gemini-2.5-flash-preview-05-20')
except Exception as e:
    print(f"Error configuring Generative AI: {e}")
    model = None

def _call_gemini_api(prompt):
    """A helper to safely call the Gemini API and parse JSON."""
    if not model:
        raise ConnectionError("Generative AI model is not configured.")
    try:
        response = model.generate_content(prompt)
        cleaned_response = response.text.strip().replace("```json", "").replace("```", "").strip()
        return json.loads(cleaned_response)
    except Exception as e:
        print(f"Error calling Gemini API or parsing JSON: {e}")
        return None

def get_thematic_summary(text: str) -> str:
    """Generates a thematic summary of the journal entry."""
    prompt = f"Summarize the key events, topics, and overall sentiment of this journal entry in a few sentences.\n\n---\n{text}\n---"
    if not model:
        return "Summary generation unavailable."
    response = model.generate_content(prompt)
    return response.text.strip()

def get_cognitive_patterns(summary: str) -> dict:
    """Extracts cognitive patterns from the summary."""
    prompt = f"""
From the summary below, identify recurring themes, the user's decision-making style (e.g., logical, emotional, cautious), and any expressed problems or challenges.
Format the output as a valid JSON object with keys: "recurring_themes" (list of strings), "decision_style" (string), "recent_sentiments" (string).

Summary:
---
{summary}
---
"""
    return _call_gemini_api(prompt)

def get_linguistic_patterns(text: str) -> dict:
    """Extracts linguistic patterns from the user's text."""
    prompt = f"""
Analyze this text from an English learner. Identify up to 3 common error types (e.g., 'Verb Tense'), assess the vocabulary level (Beginner, Intermediate, Advanced), and find one example of a linguistic strength (e.g., 'Good use of adjectives').
Format as a valid JSON object with keys: "common_errors" (list of dicts with "type" and "example"), "vocabulary_level" (string), "strength" (string).

Text:
---
{text}
---
"""
    return _call_gemini_api(prompt)

def process_journal(journal_id: int, user_id: int):
    """
    The main function for the asynchronous context agent.
    Fetches a completed journal, analyzes it, and updates the user's context profile.
    """
    db = next(database.get_db())
    try:
        journal = db.query(models.Journal).options(
            joinedload(models.Journal.chat_messages)
        ).filter(models.Journal.id == journal_id).first()

        if not journal:
            print(f"Context Agent: Journal with id {journal_id} not found.")
            return

        full_text = journal.content + "\n\nChat History:\n" + "\n".join(
            [f"{msg.sender.name}: {msg.message_text}" for msg in journal.chat_messages]
        )

        # Step 1: Thematic Summary
        summary = get_thematic_summary(full_text)

        # Steps 2 & 3: Cognitive and Linguistic Extraction
        cognitive_insights = get_cognitive_patterns(summary)
        linguistic_insights = get_linguistic_patterns(journal.content)

        # Step 4: Consolidation
        profile = db.query(models.UserContextProfile).filter(models.UserContextProfile.user_id == user_id).first()
        if not profile:
            profile = models.UserContextProfile(user_id=user_id, profile_data={})
            db.add(profile)

        # Merge new insights. A simple overwrite is robust for this structure.
        updated_profile_data = {
            "linguistic_profile": linguistic_insights or {},
            "cognitive_profile": cognitive_insights or {}
        }
        profile.profile_data = updated_profile_data
        profile.last_updated = datetime.utcnow()

        db.commit()
        print(f"Context Agent: Successfully processed journal {journal_id} for user {user_id}.")

    except Exception as e:
        print(f"Context Agent: An error occurred during processing: {e}")
        db.rollback()
    finally:
        db.close()

```


### File: app/services/ai_service.py

```
import google.generativeai as genai
from ..config import settings
import json

# Configure the Gemini API client
genai.configure(api_key=settings.gemini_api_key)
model = genai.GenerativeModel('gemini-2.5-flash-preview-05-20')

SCAFFOLDING_PROMPT_TEMPLATE = """
You are Lingo, an insightful and encouraging AI writing partner for an English language learner.
Your role is to help the user build a journal outline by asking personalized, Socratic questions.
Your tone must be curious, encouraging, and concise (10-50 words).

**CONTEXT PROVIDED (as a JSON object):**
- `user_context`: A profile of the user's learning patterns and common topics. Use this to ask relevant questions.
- `session_state`: The current journal outline and recent chat history.

**YOUR TASK:**
Based on the full context and the user's latest message, choose ONE of the following actions.
Your entire response MUST be a single, valid JSON object.

**AVAILABLE ACTIONS:**

1.  **`ASK_QUESTION`**: Ask a friendly, open-ended question to prompt reflection. This is your default action.
    - **JSON Structure**:
      ```json
      {
        "action": "ASK_QUESTION",
        "payload": { "question": "That sounds interesting. What was the most memorable part for you?" }
      }
      ```

2.  **`ADD_TO_OUTLINE`**: When a clear idea or point is established from the chat, use this to add it to the outline and ask a follow-up question.
    - **JSON Structure**:
      ```json
      {
        "action": "ADD_TO_OUTLINE",
        "payload": {
          "text_to_add": "\\n- Visited the new cafe on Main Street.",
          "follow_up_question": "Great! I've added that. What happened at the cafe?"
        }
      }
      ```

**RULES:**
- ALWAYS respond in the specified JSON format.
- Use the `user_context` to make your questions personal. For example, if their recurring theme is 'exam stress', you could ask, "How did that affect your studies today?"
- Be proactive. Your goal is to help build the outline.
- Avoid to talk about user feeling. Try to lean or direct user to talk about their actions or physical stuff. You can talk about their reason or decision. Remember we want to know their thinking pattern.
- If user dont know what they want to talk, you can direct them to talk about study. (users are students)
"""

WRITING_PARTNER_PROMPT_TEMPLATE = """
You are Lingo, an expert, collaborative English writing partner.
Your goal is to help a user write a journal entry based on their outline and current draft.
Your tone should be encouraging, specific, and helpful. You are a partner, not just a tool.
Do not be overly conversational; provide direct help based on the user's request.
Respond in plain text, not JSON.

**CONTEXT PROVIDED:**
- **Outline:** The user's plan for their journal entry.
- **Current Draft:** The text the user has written so far.
- **User's Question:** The specific request from the user.

**YOUR TASK:**
Analyze the user's question in the context of their outline and draft, and provide a direct, actionable response. Here's how to handle different types of requests:

1.  **If the user is stuck (e.g., "What should I write next?", "I'm stuck"):**
    - Look at the last sentence of their draft and the next point in their outline.
    - Suggest a transition or a starting sentence for the next idea.
    - Example: "Great start! Based on your outline, the next point is about the team meeting. You could start with something like, 'Later in the afternoon, the team meeting brought some unexpected news...'"

2.  **If the user asks for rephrasing or improvement (e.g., "How can I say this better?", "Make this sound more professional"):**
    - Identify the phrase they want to improve.
    - Provide 2-3 alternative suggestions with slightly different tones (e.g., more descriptive, more formal).
    - Example: "Instead of 'The food was good,' you could try: 'The meal was delicious and perfectly seasoned,' or 'I really enjoyed the food; it was very flavorful.'"

3.  **If the user asks a specific grammar or vocabulary question (e.g., "Is 'I goed' correct?", "What's another word for 'happy'?"):**
    - Directly answer their question.
    - Provide a short, simple explanation.
    - Example: "The past tense of 'go' is 'went,' so the correct sentence is 'I went to the store.' For 'happy,' you could use words like 'joyful,' 'elated,' or 'content,' depending on the feeling you want to express."
    
4.  **If the user asks for general feedback on their draft (e.g., "How is it so far?"):**
    - Provide one positive comment and one constructive suggestion for improvement, focusing on high-level concepts like flow, detail, or clarity, not just grammar.
    - Example: "This is a very clear description of your morning. To make it even more engaging, maybe you could add a bit more about how you felt during the commute."

**RULES:**
  - Be specific of what user asked. don't explain to long.

**CONTEXT FOR THIS REQUEST:**

- **Outline:**
---
{outline}
---

- **Current Draft:**
---
{current_draft}
---

- **User's Question:**
---
{user_message}
---
"""

EVALUATION_FEEDBACK_PROMPT_TEMPLATE = """
You are Lingo, a meticulous and encouraging English writing coach.
Your task is to analyze a complete journal entry and provide a structured evaluation to help the user learn and improve.
Your tone must be positive and empowering.

**YOUR TASK:**
Analyze the provided text. Return a single, valid JSON object with the following structure:
- `high_level_summary`: A short, positive, and encouraging comment about the overall entry.
- `feedback_items`: A list of specific feedback points.

For each feedback item, include:
- `category`: e.g., "Grammar: Verb Tense", "Vocabulary: Phrasing"
- `incorrect_phrase`: The exact phrase from the user's text.
- `suggestion`: The corrected version of the phrase.
- `explanation`: A concise, easy-to-understand explanation of the correction.

**RULES:**
- ALWAYS respond in the specified JSON format.
- Limit feedback to the 5-7 most important points to avoid overwhelming the user.
- Phrase suggestions constructively (e.g., "Consider saying..." instead of "This is wrong.").
- No need to be so strict. Only points out most meaningfull error or most meaningfull sugesstion.
- Dont overlap the error. eg text is contained in other error.
"""

QUICK_CORRECTION_PROMPT_TEMPLATE = """
You are an automated English grammar and spelling checker. Your ONLY output must be a single, valid JSON object. Do not include any explanatory text, markdown, or any characters outside of the JSON structure.

Your task is to meticulously analyze a short message from a user and identify the single most significant error.

**RULES:**
1.  Your analysis must be strict. Check for spelling errors, incorrect verb tenses, subject-verb agreement, and incorrect word usage.
2.  Focus on only ONE error. If there are multiple, choose the most obvious one (spelling errors are high priority).
3.  If you find an error, you MUST respond with a valid JSON object with FOUR keys:
    - `incorrect_phrase`: The exact text from the user's message that is incorrect.
    - `suggestion`: The corrected version of that phrase.
    - `explanation`: A very brief, one-sentence explanation of why it was wrong.
    - `status`: MUST be the string "correction_found".

4.  If the user's message is grammatically perfect and has no spelling errors, you MUST respond with a valid JSON object with only ONE key:
    - `status`: MUST be the string "no_errors".
5.  Your entire response must be ONLY the JSON object.

**EXAMPLE 1 (Error Found):**
User's Message: "There is many clanlanges."
Your JSON Response:
```json
{{
  "incorrect_phrase": "There is many clanlanges",
  "suggestion": "There are many languages",
  "explanation": "'Are' is used for plural nouns like 'languages', and 'languages' was misspelled.",
  "status": "correction_found"
}}
```

**EXAMPLE 2 (No Error Found):**
User's Message: "I went to the store yesterday."
Your JSON Response:
```json
{{
  "status": "no_errors"
}}
```

**Analyze the following message:**

User's Message:
---
{user_message}
---
"""


def get_scaffolding_response(user_context: dict, session_state: dict) -> dict:
    """
    Generates a response for the 'scaffolding' phase.
    """
    try:
        context_payload = {
            "user_context": user_context,
            "session_state": session_state
        }
        full_prompt = f"{SCAFFOLDING_PROMPT_TEMPLATE}\n\nHere is the current context:\n\n---\n{json.dumps(context_payload, indent=2)}\n---"

        response = model.generate_content(full_prompt)
        cleaned_response = response.text.strip().replace("```json", "").replace("```", "").strip()
        return json.loads(cleaned_response)
    except Exception as e:
        print(f"An error occurred with the Gemini API during scaffolding: {e}")
        # Return a safe default response
        return {
            "action": "ASK_QUESTION",
            "payload": { "question": "I'm sorry, I'm having a little trouble thinking. Could you rephrase that?" }
        }

def get_writing_partner_response(user_message: str, outline: str, current_draft: str) -> str:
    """
    Generates a helpful, context-aware response for the 'writing' phase.
    """
    try:
        full_prompt = WRITING_PARTNER_PROMPT_TEMPLATE.format(
            user_message=user_message,
            outline=outline or "No outline provided.", # Handle empty outline
            current_draft=current_draft or "The user has not written anything yet." # Handle empty draft
        )
        response = model.generate_content(full_prompt)
        return response.text.strip()
    except Exception as e:
        print(f"An error occurred with the Gemini API during writing assistance: {e}")
        return "I'm sorry, I'm unable to help with that right now."

def get_evaluation_feedback(text: str) -> dict:
    """
    Generates final, structured feedback for the 'evaluation' phase.
    """
    try:
        full_prompt = f"{EVALUATION_FEEDBACK_PROMPT_TEMPLATE}\n\nHere is the user's journal entry to analyze:\n\n---\n{text}\n---"
        response = model.generate_content(full_prompt)
        cleaned_response = response.text.strip().replace("```json", "").replace("```", "").strip()
        
        parsed_data = json.loads(cleaned_response)

        # Check for and correct the common AI typo for the summary field
        if 'high_level_level_summary' in parsed_data:
            parsed_data['high_level_summary'] = parsed_data.pop('high_level_level_summary')
        
        return parsed_data
    except Exception as e:
        print(f"An error occurred with the Gemini API during evaluation feedback: {e}")
        return {
            "high_level_summary": "There was an issue analyzing the text. Please try again.",
            "feedback_items": []
        }

def get_quick_correction(user_message: str) -> dict:
    """
    Analyzes a short user message and returns a single grammar/spelling correction.
    """
    cleaned_response = ""
    # try:
    full_prompt = QUICK_CORRECTION_PROMPT_TEMPLATE.format(user_message=user_message)
    response = model.generate_content(full_prompt)
    print(response)
    # --- NEW: More robust check for a valid response ---
    if not response.parts:
        print("--- AI RESPONSE ERROR ---")
        print(f"AI response was empty or blocked. Candidates: {response.candidates}")
        print("-------------------------")
        return {"status": "no_errors"}

    cleaned_response = response.text.strip().replace("```json", "").replace("```", "").strip()
    
    if not cleaned_response:
        return {"status": "no_errors"}
        
    return json.loads(cleaned_response)
    # except Exception as e:
    #     print(f"An error occurred during quick correction: {e}")
    #     # --- NEW LOGGING ---
    #     print(f"--- FAILED TO PARSE AI RESPONSE ---")
    #     print(f"Raw response text: '{cleaned_response}'")
    #     print(f"------------------------------------")
    #     # --- END NEW LOGGING ---
    #     return {"status": "no_errors"}


```


### File: app/routers/journals.py

```
from fastapi import APIRouter, BackgroundTasks, Depends, HTTPException, status
from sqlalchemy.orm import Session
from datetime import date
from typing import List

from .. import database, schemas, models, security
from ..services import context_agent

router = APIRouter(
    prefix="/api/journals",
    tags=["Journals"]
)

@router.post("/", response_model=schemas.JournalOut, status_code=status.HTTP_201_CREATED)
def create_journal(
    journal: schemas.JournalCreate, 
    db: Session = Depends(database.get_db), 
    current_user: models.User = Depends(security.get_current_user)
):
    """
    Creates a new journal entry for the current user for today's date.
    A user can only create one journal entry per day.
    """
    today = date.today()
    
    # Check if a journal entry for today already exists for this user
    existing_journal = db.query(models.Journal).filter(
        models.Journal.user_id == current_user.id,
        models.Journal.journal_date == today
    ).first()

    if existing_journal:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="A journal entry for today already exists."
        )

    # Create the new journal entry
    new_journal = models.Journal(
        user_id=current_user.id,
        journal_date=today,
        content=journal.content or "",
        outline_content = "" # Ensure it's not null
    )
    db.add(new_journal)
    db.commit()
    db.refresh(new_journal)
    
    return new_journal

@router.get("/", response_model=List[schemas.JournalOut])
def get_all_journals(
    db: Session = Depends(database.get_db),
    current_user: models.User = Depends(security.get_current_user)
):
    """
    Retrieves all journal entries for the currently logged-in user.
    """
    journals = db.query(models.Journal).filter(models.Journal.user_id == current_user.id).order_by(models.Journal.journal_date.desc()).all()
    return journals

@router.get("/{journal_date}", response_model=schemas.JournalOut)
def get_journal_by_date(
    journal_date: date,
    db: Session = Depends(database.get_db),
    current_user: models.User = Depends(security.get_current_user)
):
    """
    Retrieves a specific journal entry by date for the current user.
    """
    journal = db.query(models.Journal).filter(
        models.Journal.user_id == current_user.id,
        models.Journal.journal_date == journal_date
    ).first()

    if not journal:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Journal entry for date {journal_date} not found."
        )
    
    return journal

@router.put("/{journal_date}", response_model=schemas.JournalOut)
def update_journal(
    journal_date: date,
    updated_journal: schemas.JournalUpdate,
    db: Session = Depends(database.get_db),
    current_user: models.User = Depends(security.get_current_user)
):
    """
    Updates the content of a specific journal entry by date for the current user.
    """
    journal = db.query(models.Journal).filter(
        models.Journal.user_id == current_user.id,
        models.Journal.journal_date == journal_date
    ).first()

    if not journal:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Journal entry for date {journal_date} not found."
        )
    
    # Update the journal content
    journal.content = updated_journal.content
    if updated_journal.outline_content is not None:
        journal.outline_content = updated_journal.outline_content

    db.commit()
    db.refresh(journal)
    
    return journal

@router.put("/{journal_date}/phase", response_model=schemas.JournalOut)
def update_journal_phase(
    journal_date: date,
    updated_phase: schemas.JournalPhaseUpdate,
    background_tasks: BackgroundTasks,
    db: Session = Depends(database.get_db),
    current_user: models.User = Depends(security.get_current_user)
):
    """
    Updates the writing phase of a specific journal entry.
    """
    journal = db.query(models.Journal).filter(
        models.Journal.user_id == current_user.id,
        models.Journal.journal_date == journal_date
    ).first()

    if not journal:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Journal entry for date {journal_date} not found."
        )

    # --- FIX STARTS HERE ---

    # 1. Add this line to update the phase from the request
    journal.writing_phase = updated_phase.phase 

    # 2. Add this line to save the change to the database
    db.commit()

    # --- FIX ENDS HERE ---

    # This part handles kicking off background tasks after a journal is completed
    if journal.writing_phase == models.JournalPhase.completed:
        background_tasks.add_task(
            context_agent.process_journal, journal.id, current_user.id
        )

    db.refresh(journal)

    return journal


```


### File: app/routers/auth.py

```
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from .. import database, schemas, models, security

router = APIRouter(
    prefix="/api/auth",
    tags=["Authentication"]
)

@router.post("/signup", response_model=schemas.UserOut, status_code=status.HTTP_201_CREATED)
def create_user(user: schemas.UserCreate, db: Session = Depends(database.get_db)):
    """
    Handles user registration with whitelist validation.
    - Hashes the password.
    - Checks for existing user/email/student_id.
    - Validates student_id and email against the StudentWhitelist.
    - Creates a new user in the database.
    """
    # --- NEW: Whitelist Validation ---
    whitelisted_student = db.query(models.StudentWhitelist).filter(models.StudentWhitelist.student_id == user.student_id).first()
    
    if not whitelisted_student:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Student ID is not approved for registration."
        )

    # Case-insensitive email comparison
    if whitelisted_student.email.lower() != user.email.lower():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="The provided email does not match the one registered for this Student ID."
        )
    # --- END NEW: Whitelist Validation ---

    # Check if a user with the same email or username already exists
    db_user_email = db.query(models.User).filter(models.User.email == user.email).first()
    if db_user_email:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered."
        )
    
    db_user_username = db.query(models.User).filter(models.User.username == user.username).first()
    if db_user_username:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username is already taken."
        )

    db_user_studentid = db.query(models.User).filter(models.User.student_id == user.student_id).first()
    if db_user_studentid:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Student ID is already registered."
        )

    # Hash the password before storing
    hashed_password = security.get_password_hash(user.password)
    
    # Create a new user instance and save to the database
    new_user = models.User(
        username=user.username,
        email=user.email,
        realname=user.realname,
        student_id=user.student_id,
        group=user.group,
        hashed_password=hashed_password
    )
    db.add(new_user)
    db.commit()
    db.refresh(new_user) # Refresh the instance to get the new ID and created_at

    return new_user


@router.post("/token", response_model=schemas.Token)
def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(database.get_db)):
    """
    Handles user login.
    - Verifies username and password.
    - Returns a JWT access token on success.
    """
    # Find the user by their username (form_data.username)
    user = db.query(models.User).filter(models.User.username == form_data.username).first()

    # If user doesn't exist or password doesn't match, raise an error
    if not user or not security.verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # Create the access token
    access_token = security.create_access_token(
        data={"user_id": user.id}
    )
    
    return {"access_token": access_token, "token_type": "bearer"}

@router.get("/me", response_model=schemas.UserOut)
def read_users_me(current_user: models.User = Depends(security.get_current_user)):
    """
    Fetches the profile for the currently logged-in user.
    Requires a valid JWT in the Authorization header.
    """
    return current_user

```


### File: app/routers/admin.py

```
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from sqlalchemy import func, desc, cast, Date as SQLDate
from typing import List
from datetime import date, timedelta

from .. import database, schemas, models, security

router = APIRouter(
    prefix="/api/admin",
    tags=["Admin"],
    dependencies=[Depends(security.get_current_admin_user)]
)

@router.get("/students", response_model=List[schemas.AdminStudentSummary])
def get_all_students(db: Session = Depends(database.get_db)):
    """
    Retrieves a list of all non-admin users (students) with summary stats.
    """
    students_query = db.query(
        models.User,
        func.count(models.Journal.id).label("journal_count"),
        func.max(models.Journal.updated_at).label("last_active")
    ).outerjoin(models.Journal, models.User.id == models.Journal.user_id)\
    .filter(models.User.is_admin == False)\
    .group_by(models.User.id).all()

    results = []
    for user, journal_count, last_active in students_query:
        total_errors = db.query(func.count(models.UserError.id)).filter(models.UserError.user_id == user.id).scalar()
        
        student_summary = schemas.AdminStudentSummary(
            id=user.id,
            username=user.username,
            email=user.email,
            realname=user.realname,
            student_id=user.student_id,
            group=user.group,
            created_at=user.created_at,
            is_admin=user.is_admin,
            journal_count=journal_count,
            total_errors=total_errors or 0,
            last_active=last_active
        )
        results.append(student_summary)
        
    return results

@router.get("/students/{student_id}", response_model=schemas.AdminStudentDetail)
def get_student_details(student_id: int, db: Session = Depends(database.get_db)):
    """
    Retrieves detailed analytics for a specific student.
    """
    student = db.query(models.User).filter(models.User.id == student_id, models.User.is_admin == False).first()
    if not student:
        raise HTTPException(status_code=404, detail="Student not found.")

    # Base summary stats
    journal_count = db.query(func.count(models.Journal.id)).filter(models.Journal.user_id == student_id).scalar()
    total_errors = db.query(func.count(models.UserError.id)).filter(models.UserError.user_id == student_id).scalar()
    last_active = db.query(func.max(models.Journal.updated_at)).filter(models.Journal.user_id == student_id).scalar()

    # Error distribution by topic
    error_distribution_query = db.query(
        models.LearningTopic.topic_name,
        func.count(models.UserError.id).label("error_count")
    ).join(models.LearningTopic, models.UserError.topic_id == models.LearningTopic.id)\
    .filter(models.UserError.user_id == student_id)\
    .group_by(models.LearningTopic.topic_name)\
    .order_by(desc("error_count")).all()
    
    # Error trend over the last 30 days
    thirty_days_ago = date.today() - timedelta(days=30)
    error_trend_query = db.query(
        cast(models.UserError.last_occurred_at, SQLDate).label("date"),
        func.count(models.UserError.id).label("error_count")
    ).filter(
        models.UserError.user_id == student_id,
        models.UserError.last_occurred_at >= thirty_days_ago
    ).group_by(cast(models.UserError.last_occurred_at, SQLDate))\
    .order_by(cast(models.UserError.last_occurred_at, SQLDate)).all()

    return {
        "id": student.id,
        "username": student.username,
        "email": student.email,
        "realname": student.realname,
        "student_id": student.student_id,
        "group": student.group,
        "created_at": student.created_at,
        "is_admin": student.is_admin,
        "journal_count": journal_count,
        "total_errors": total_errors or 0,
        "last_active": last_active,
        "error_distribution": error_distribution_query,
        "error_trend": error_trend_query
    }


@router.get("/analytics/error-distribution", response_model=List[schemas.AdminErrorDistributionItem])
def get_class_error_distribution(db: Session = Depends(database.get_db)):
    """
    Gets the aggregated distribution of errors by topic for the entire class.
    """
    return db.query(
        models.LearningTopic.topic_name,
        func.count(models.UserError.id).label("error_count")
    ).join(models.LearningTopic, models.UserError.topic_id == models.LearningTopic.id)\
    .join(models.User, models.UserError.user_id == models.User.id)\
    .filter(models.User.is_admin == False)\
    .group_by(models.LearningTopic.topic_name)\
    .order_by(desc("error_count")).all()


@router.get("/analytics/error-trend", response_model=List[schemas.AdminErrorTrendPoint])
def get_class_error_trend(db: Session = Depends(database.get_db)):
    """
    Gets the trend of total errors per day for the entire class over the last 30 days.
    """
    thirty_days_ago = date.today() - timedelta(days=30)
    return db.query(
        cast(models.UserError.last_occurred_at, SQLDate).label("date"),
        func.count(models.UserError.id).label("error_count")
    ).join(models.User, models.UserError.user_id == models.User.id)\
    .filter(
        models.User.is_admin == False,
        models.UserError.last_occurred_at >= thirty_days_ago
    ).group_by(cast(models.UserError.last_occurred_at, SQLDate))\
    .order_by(cast(models.UserError.last_occurred_at, SQLDate)).all()

# NEW ENDPOINT to get all journals for a student
@router.get("/students/{student_id}/journals", response_model=List[schemas.JournalOut])
def get_student_journals(student_id: int, db: Session = Depends(database.get_db)):
    """
    Retrieves all journal entries for a specific student.
    """
    student = db.query(models.User).filter(models.User.id == student_id, models.User.is_admin == False).first()
    if not student:
        raise HTTPException(status_code=404, detail="Student not found.")

    journals = db.query(models.Journal).filter(models.Journal.user_id == student_id).order_by(models.Journal.journal_date.desc()).all()
    return journals

# NEW ENDPOINT to get a single journal for a student
@router.get("/students/{student_id}/journals/{journal_date}", response_model=schemas.JournalOut)
def get_student_journal_by_date(student_id: int, journal_date: date, db: Session = Depends(database.get_db)):
    """
    Retrieves a specific journal entry by date for a specific student.
    """
    journal = db.query(models.Journal).filter(
        models.Journal.user_id == student_id,
        models.Journal.journal_date == journal_date
    ).first()

    if not journal:
        raise HTTPException(
            status_code=404,
            detail=f"Journal entry for date {journal_date} not found for student {student_id}."
        )
    
    return journal

# --- NEW Endpoints for Student Whitelist Management ---

@router.post("/whitelist", response_model=schemas.StudentWhitelistOut, status_code=status.HTTP_201_CREATED)
def add_student_to_whitelist(
    student_data: schemas.StudentWhitelistCreate, 
    db: Session = Depends(database.get_db)
):
    """
    Adds a student's ID and email to the registration whitelist.
    """
    existing_student = db.query(models.StudentWhitelist).filter(models.StudentWhitelist.student_id == student_data.student_id).first()
    if existing_student:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="A student with this ID is already on the whitelist."
        )
    
    new_student = models.StudentWhitelist(**student_data.model_dump())
    db.add(new_student)
    db.commit()
    db.refresh(new_student)
    return new_student

@router.get("/whitelist", response_model=List[schemas.StudentWhitelistOut])
def get_student_whitelist(db: Session = Depends(database.get_db)):
    """
    Retrieves the entire student registration whitelist.
    """
    return db.query(models.StudentWhitelist).order_by(models.StudentWhitelist.student_id).all()

@router.delete("/whitelist/{student_id}", status_code=status.HTTP_204_NO_CONTENT)
def remove_student_from_whitelist(student_id: str, db: Session = Depends(database.get_db)):
    """
    Removes a student from the registration whitelist by their student ID.
    """
    student_to_delete = db.query(models.StudentWhitelist).filter(models.StudentWhitelist.student_id == student_id).first()
    if not student_to_delete:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Student with ID '{student_id}' not found on the whitelist."
        )
    
    db.delete(student_to_delete)
    db.commit()
    return 

```


### File: app/routers/progress.py

```
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from sqlalchemy import func, desc
from typing import List
from sqlalchemy.orm import joinedload
from datetime import date, timedelta

from .. import database, schemas, models, security

router = APIRouter(
    prefix="/api/progress",
    tags=["Progress"]
)

@router.get("/summary", response_model=schemas.ProgressSummary)
def get_progress_summary(
    db: Session = Depends(database.get_db),
    current_user: models.User = Depends(security.get_current_user)
):
    """
    Retrieves a high-level summary of the user's learning progress,
    including total errors and top 3 most common error topics.
    """
    user_id = current_user.id

    # 1. Calculate total errors
    total_errors = db.query(models.UserError).filter(models.UserError.user_id == user_id).count()

    # 2. Calculate total unique topics encountered
    topics_encountered = db.query(func.count(func.distinct(models.UserError.topic_id))).filter(models.UserError.user_id == user_id).scalar() or 0

    # 3. Find the top 3 topics with the most errors
    # We join UserError with LearningTopic, group by topic,
    # count the errors in each group, and take the top 3.
    top_topics_query = db.query(
        models.LearningTopic.topic_name,
        func.count(models.UserError.id).label("error_count")
    ).join(
        models.LearningTopic, models.UserError.topic_id == models.LearningTopic.id
    ).filter(
        models.UserError.user_id == user_id
    ).group_by(
        models.LearningTopic.topic_name
    ).order_by(
        desc("error_count")
    ).limit(3).all()

    # Format the result to match the Pydantic schema
    top_topics = [schemas.TopTopic(topic_name=name, error_count=count) for name, count in top_topics_query]
    
    return {
        "total_errors": total_errors,
        "topics_encountered": topics_encountered,
        "top_topics": top_topics
    }

# --- New Endpoint 1: Get All Topics ---
@router.get("/topics", response_model=List[schemas.UserTopic])
def get_user_topics(
    db: Session = Depends(database.get_db),
    current_user: models.User = Depends(security.get_current_user)
):
    """
    Retrieves all learning topics a user has encountered, along with the
    count of unique errors for each topic.
    """
    user_id = current_user.id

    topics_query = db.query(
        models.LearningTopic.id.label("topic_id"),
        models.LearningTopic.topic_name,
        func.count(models.UserError.id).label("error_count")
    ).join(
        models.LearningTopic, models.UserError.topic_id == models.LearningTopic.id
    ).filter(
        models.UserError.user_id == user_id
    ).group_by(
        models.LearningTopic.id, models.LearningTopic.topic_name
    ).order_by(
        desc("error_count")
    ).all()

    return topics_query


# --- New Endpoint 2: Get Topic Details ---
@router.get("/topics/{topic_id}", response_model=schemas.UserTopicDetails)
def get_topic_details(
    topic_id: int,
    db: Session = Depends(database.get_db),
    current_user: models.User = Depends(security.get_current_user)
):
    """
    Retrieves detailed information for a specific topic, including all
    associated errors and their corresponding learning points (explanations).
    """
    user_id = current_user.id

    # 1. Get the topic info and error count first
    topic_info = db.query(
        models.LearningTopic.id.label("topic_id"),
        models.LearningTopic.topic_name,
        func.count(models.UserError.id).label("error_count")
    ).join(
        models.LearningTopic, models.UserError.topic_id == models.LearningTopic.id
    ).filter(
        models.UserError.user_id == user_id,
        models.LearningTopic.id == topic_id
    ).group_by(
        models.LearningTopic.id, models.LearningTopic.topic_name
    ).first()

    if not topic_info:
        raise HTTPException(status_code=404, detail="Topic not found for this user.")

    # 2. Get all errors for this topic, joining with history and learning points
    # to fetch the explanation and suggestion for each error.
    errors_query = db.query(
        models.UserError.incorrect_phrase,
        models.LearningPoint.suggestion_text,
        models.LearningPoint.explanation_text,
        models.UserError.repetition_count,
        models.UserError.last_occurred_at
    ).select_from(models.UserError).join(
        models.UserLearningHistory, models.UserError.id == models.UserLearningHistory.error_id
    ).join(
        models.LearningPoint, models.UserLearningHistory.learning_point_id == models.LearningPoint.id
    ).filter(
        models.UserError.user_id == user_id,
        models.UserError.topic_id == topic_id
    ).distinct().all()
    
    return {
        "topic_id": topic_info.topic_id,
        "topic_name": topic_info.topic_name,
        "error_count": topic_info.error_count,
        "errors": errors_query
    }

@router.get("/streak", response_model=schemas.StreakOut)
def get_user_streak(
    db: Session = Depends(database.get_db),
    current_user: models.User = Depends(security.get_current_user)
):
    """
    Calculates the user's current writing streak based on consecutive daily
    journal entries.
    """
    # 1. Fetch all unique journal dates for the user, sorted from newest to oldest.
    journal_dates_query = db.query(models.Journal.journal_date).filter(
        models.Journal.user_id == current_user.id
    ).distinct().order_by(models.Journal.journal_date.desc()).all()
    
    # Extract date objects from the query result
    journal_dates = [item.journal_date for item in journal_dates_query]

    if not journal_dates:
        return {"streak_count": 0}

    # 2. Check if the streak is active.
    today = date.today()
    most_recent_date = journal_dates[0]
    
    # If the most recent entry is older than yesterday, the streak is broken.
    if most_recent_date < today - timedelta(days=1):
        return {"streak_count": 0}

    # 3. Calculate the streak length.
    streak_count = 1
    last_date = most_recent_date

    # Iterate through the rest of the dates to find consecutive days.
    for i in range(1, len(journal_dates)):
        current_date = journal_dates[i]
        # If the gap between the last date and the current date is exactly one day,
        # it's a consecutive entry.
        if last_date - current_date == timedelta(days=1):
            streak_count += 1
            last_date = current_date
        else:
            # If the chain is broken, stop counting.
            break
            
    return {"streak_count": streak_count}
```


### File: app/routers/ai.py

```
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from datetime import date, datetime
from sqlalchemy.orm import joinedload
import json

from .. import schemas, security, models, database
from ..services import ai_service

router = APIRouter(
    prefix="/api/ai",
    tags=["AI"]
)

@router.post("/feedback/{journal_date}", response_model=schemas.AIFeedbackResponse)
def get_and_save_ai_feedback(
    journal_date: date,
    request: schemas.AIFeedbackRequest,
    db: Session = Depends(database.get_db),
    current_user: models.User = Depends(security.get_current_user)
):
    """
    Analyzes a journal entry's content for the 'evaluation' phase, returns structured AI feedback,
    and saves any learning points derived from the feedback to the database.
    """
    journal = db.query(models.Journal).filter(
        models.Journal.user_id == current_user.id,
        models.Journal.journal_date == journal_date
    ).first()

    if not journal:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Journal entry for date {journal_date} not found."
        )

    feedback_data = ai_service.get_evaluation_feedback(request.text)

    if not feedback_data or "feedback_items" not in feedback_data:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="The AI service is currently unavailable or returned invalid data."
        )

    # Save learning points logic
    for item_data in feedback_data["feedback_items"]:
        item = schemas.AIFeedbackItem(**item_data)
        topic = db.query(models.LearningTopic).filter(models.LearningTopic.topic_name == item.category).first()
        if not topic:
            topic = models.LearningTopic(topic_name=item.category)
            db.add(topic)
            db.commit()
            db.refresh(topic)

        user_error = db.query(models.UserError).filter(
            models.UserError.user_id == current_user.id,
            models.UserError.topic_id == topic.id,
            models.UserError.incorrect_phrase == item.incorrect_phrase
        ).first()
        
        if user_error:
            user_error.repetition_count += 1
            user_error.last_occurred_at = datetime.utcnow()
        else:
            user_error = models.UserError(
                user_id=current_user.id,
                topic_id=topic.id,
                incorrect_phrase=item.incorrect_phrase
            )
            db.add(user_error)
        db.commit()
        db.refresh(user_error)

        learning_point = db.query(models.LearningPoint).filter(
            models.LearningPoint.topic_id == topic.id,
            models.LearningPoint.explanation_text == item.explanation
        ).first()

        if not learning_point:
            learning_point = models.LearningPoint(
                topic_id=topic.id,
                explanation_text=item.explanation,
                suggestion_text=item.suggestion
            )
            db.add(learning_point)
            db.commit()
            db.refresh(learning_point)

        history_record = models.UserLearningHistory(
            error_id=user_error.id,
            learning_point_id=learning_point.id
        )
        db.add(history_record)
        db.commit()

    return feedback_data

@router.post("/chat/{journal_date}", response_model=schemas.JournalOut)
def chat_with_ai(
    journal_date: date,
    request: schemas.AIChatRequest,
    db: Session = Depends(database.get_db),
    current_user: models.User = Depends(security.get_current_user)
):
    """
    Handles a real-time conversation turn with the AI.
    Optionally provides a quick correction if requested.
    Returns the entire updated journal object to prevent race conditions.
    """
    journal = db.query(models.Journal).options(
        joinedload(models.Journal.chat_messages),
        joinedload(models.Journal.owner).joinedload(models.User.context_profile)
    ).filter(
        models.Journal.user_id == current_user.id,
        models.Journal.journal_date == journal_date
    ).first()

    if not journal:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Journal entry for date {journal_date} not found."
        )
        
    # 1. Add user's message to the session
    user_message = models.ChatMessage(
        journal_id=journal.id,
        sender=models.MessageSender.user,
        message_text=request.message,
        message_type=models.MessageType.conversation
    )
    db.add(user_message)

    # 2. Get AI responses BEFORE committing anything.
    temp_chat_history = [
        {"role": msg.sender.name, "content": msg.message_text}
        for msg in journal.chat_messages
        if msg.message_type == models.MessageType.conversation
    ]
    temp_chat_history.append({"role": "user", "content": request.message})

    # A) Get conversational response
    ai_message_text = "I'm not sure how to respond to that." # Default
    if journal.writing_phase == models.JournalPhase.scaffolding:
        session_state = {
            "current_outline": journal.outline_content,
            "chat_history": temp_chat_history,
        }
        user_context = journal.owner.context_profile.profile_data if journal.owner.context_profile and journal.owner.context_profile.profile_data else {}
        ai_response = ai_service.get_scaffolding_response(user_context, session_state)
        action = ai_response.get("action")
        payload = ai_response.get("payload", {})

        if action == "ADD_TO_OUTLINE":
            journal.outline_content = (journal.outline_content or "") + payload.get("text_to_add", "")
            ai_message_text = payload.get("follow_up_question", "I've added that. What's next?")
        else:
            ai_message_text = payload.get("question", "What would you like to discuss?")

    elif journal.writing_phase == models.JournalPhase.writing:
        ai_message_text = ai_service.get_writing_partner_response(
            user_message=request.message,
            outline=journal.outline_content,
            current_draft=journal.content
        )
    
    # B) Get correction response and add feedback message (if enabled)
    if request.enable_correction:
        correction_data = ai_service.get_quick_correction(request.message)
        
        feedback_payload = {}
        # Check not only for key existence but also for non-empty string values.
        if (correction_data 
            and 'incorrect_phrase' in correction_data and correction_data.get('incorrect_phrase')
            and 'suggestion' in correction_data and correction_data.get('suggestion')):
            feedback_payload = correction_data
        # Otherwise, regardless of what the AI sent, we classify it as "no errors found".
        # This prevents empty/broken feedback cards in the UI.
        else:
            feedback_payload = {"status": "no_errors"}

        feedback_message = models.ChatMessage(
            journal_id=journal.id,
            sender=models.MessageSender.ai,
            message_text=json.dumps(feedback_payload),
            message_type=models.MessageType.feedback
        )
        db.add(feedback_message)

    # 3. Add AI's conversational message to the session
    ai_conv_message = models.ChatMessage(
        journal_id=journal.id,
        sender=models.MessageSender.ai,
        message_text=ai_message_text,
        message_type=models.MessageType.conversation
    )
    db.add(ai_conv_message)

    # 4. Commit all new messages (user, feedback, conversation) at once
    db.commit()
    db.refresh(journal)

    return journal


```
